<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="health-data-analysis" class="level1">
<h1>2025 Health Data Analysis</h1>
<hr>
<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>This project analyzes a full year of Apple Health step data to quantify how daily activity shifts across the academic calendar and whether routine leaves a learnable signal in the data. <strong>Fall semester</strong> produced the highest average daily steps (<strong>9,163</strong>), <strong>Summer break</strong> the lowest (<strong>7,580</strong>), with <strong>Spring semester</strong> in between (<strong>7,398</strong>). A <strong>Gradient Boosting classifier</strong> predicted weekday vs.&nbsp;weekend from hourly step patterns with <strong>84% accuracy</strong> and <strong>AUC 0.82</strong>, outperforming a baseline by 10 percentage points. <strong>Next-day step forecasting</strong> achieved only <strong>R² ≈ 0.07</strong>, showing that daily <em>patterns</em> are predictable while daily <em>volume</em> is not. The so-what: structure (semesters, weekdays) drives both step levels and discriminative hourly profiles; without that structure, activity and predictability drop.</p>
<hr>
</section>
<section id="project-background" class="level2">
<h2 class="anchored" data-anchor-id="project-background">Project Background</h2>
<p>Understanding how daily movement varies with life context supports better health planning and goal-setting. For individuals whose schedules are tied to academic or work calendars, step data can reveal whether activity is consistently higher during structured periods (e.g., semesters) and lower during breaks, and whether weekday and weekend behavior are distinguishable. Quantifying these patterns helps set realistic targets and identify when intervention or habit-building may be most impactful.</p>
<p>This project uses <strong>365 days</strong> of iPhone step data exported from the Apple Health app to answer three questions: how daily activity shifts across <strong>Spring semester</strong> (Jan–May), <strong>Summer break</strong> (Jun–Jul), and <strong>Fall semester</strong> (Aug–Dec); whether weekday and weekend step distributions are statistically distinguishable and whether a machine learning model can classify day type from hourly profiles alone; and whether next-day step count can be predicted from recent walking history. The analysis progresses from exploratory visualization and summary statistics to hypothesis testing, supervised classification, and time series forecasting.</p>
<p>The work is framed around a single user (university student) and a single year, but the methodology and findings are relevant to any setting where calendar-driven routine is expected to influence activity. The contrast between strong classification performance and weak forecasting performance is a central takeaway: <strong>structure is learnable; volume is not.</strong></p>
<hr>
</section>
<section id="data-structure-erd" class="level2">
<h2 class="anchored" data-anchor-id="data-structure-erd">Data Structure &amp; ERD</h2>
<p>The analysis uses one primary data source: an <strong>Apple Health export</strong> (<code>export.xml</code>), which is stream-parsed and filtered to the calendar year 2025 and to records from a single source device. After filtering, the pipeline produces the following logical entities:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 39%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Table / Concept</th>
<th>Description</th>
<th>Key Columns</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Raw records</strong></td>
<td>One row per HealthKit sample</td>
<td><code>type</code>, <code>sourceName</code>, <code>startDate</code>, <code>endDate</code>, <code>value</code>, <code>unit</code></td>
</tr>
<tr class="even">
<td><strong>Daily totals</strong></td>
<td>One row per calendar day</td>
<td><code>date</code>, <code>Steps</code>, <code>FlightsClimbed</code>, <code>period</code>, <code>weekday</code>, <code>day_type</code> (weekday/weekend)</td>
</tr>
<tr class="odd">
<td><strong>Hourly pivot</strong></td>
<td>Steps by day and hour (for classification)</td>
<td><code>day</code>, <code>hour_0</code> … <code>hour_23</code>, derived <code>total_steps</code>, <code>peak_hour</code>, <code>active_hours</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>type:</strong> e.g.&nbsp;<code>HKQuantityTypeIdentifierStepCount</code>; analysis uses step count only.<br>
</li>
<li><strong>startDate / endDate:</strong> Timestamp of the sample; used to assign <code>date</code> and <code>hour</code>.<br>
</li>
<li><strong>value:</strong> Numeric quantity (steps per sample).<br>
</li>
<li><strong>period:</strong> Derived from date — Spring Semester (Jan–May), Summer Break (Jun–Jul), Fall Semester (Aug–Dec).<br>
</li>
<li><strong>day_type:</strong> Derived from <code>weekday</code> — weekday (Mon–Fri) vs.&nbsp;weekend (Sat–Sun).</li>
</ul>
<p>Conceptual data flow (raw → daily → hourly):</p>
<pre class="mermaid"><code>erDiagram
    RawRecords ||--o{ DailyTotals : "aggregates to"
    DailyTotals ||--o| HourlyPivot : "feeds"
    RawRecords {
        string type
        string sourceName
        datetime startDate
        datetime endDate
        float value
        string unit
    }
    DailyTotals {
        date date
        int Steps
        int FlightsClimbed
        string period
        int weekday
        string day_type
    }
    HourlyPivot {
        date day
        int hour_0_to_23
        int total_steps
        int peak_hour
        int active_hours
    }</code></pre>
<p>Rendered image (generated from the notebook; see <em>Technical Implementation</em>):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="docs/erd.png" class="img-fluid figure-img"></p>
<figcaption>ERD</figcaption>
</figure>
</div>
<hr>
</section>
<section id="insights-deep-dive" class="level2">
<h2 class="anchored" data-anchor-id="insights-deep-dive">Insights Deep Dive</h2>
<section id="activity-by-academic-period" class="level3">
<h3 class="anchored" data-anchor-id="activity-by-academic-period">Activity by Academic Period</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Period</th>
<th>Days</th>
<th>Mean steps</th>
<th>Median steps</th>
<th>Min</th>
<th>Max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Spring Semester</td>
<td>151</td>
<td>7,398</td>
<td>7,403</td>
<td>96</td>
<td>25,512</td>
</tr>
<tr class="even">
<td>Summer Break</td>
<td>61</td>
<td>7,580</td>
<td>7,250</td>
<td>788</td>
<td>20,300</td>
</tr>
<tr class="odd">
<td>Fall Semester</td>
<td>153</td>
<td><strong>9,163</strong></td>
<td><strong>9,330</strong></td>
<td>136</td>
<td>21,137</td>
</tr>
</tbody>
</table>
<p><strong>Metric:</strong> Fall semester mean daily steps are <strong>~24% higher</strong> than Spring and <strong>~21% higher</strong> than Summer.</p>
<p><strong>Narrative:</strong> Daily step counts align with the academic calendar. Fall semester shows a clear step premium, consistent with a campus that requires more walking between buildings. Spring is moderate; Summer establishes a lower, less structured baseline. Rolling 7- and 30-day averages make the ramp-up at semester start and the drop into breaks visually clear. The “so what” is that <strong>environment and schedule drive step volume</strong> in a consistent, measurable way.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="docs/fig_activity_by_period.png" class="img-fluid figure-img"></p>
<figcaption>Activity by period</figcaption>
</figure>
</div>
<hr>
</section>
<section id="weekday-vs.-weekend-patterns" class="level3">
<h3 class="anchored" data-anchor-id="weekday-vs.-weekend-patterns">Weekday vs.&nbsp;Weekend Patterns</h3>
<p><strong>Metric:</strong> Weekday vs.&nbsp;weekend separation in mean steps is <strong>largest during Fall semester</strong> and <strong>smallest during Summer break</strong>; Mann-Whitney U tests did not reach significance at α = 0.05 in any single period, consistent with high day-to-day variability.</p>
<p><strong>Narrative:</strong> Day-of-week box plots show higher median steps on weekdays (especially mid-week) than on weekends during semesters. The weekday/weekend gap is most pronounced in Fall and nearly absent in Summer, when no fixed schedule differentiates days. Hourly profiles show weekday peaks at <strong>9 AM, 5–6 PM, and 10 PM</strong> (class and commute times) and flatter, lower weekend curves. During Summer, weekday and weekend hourly profiles overlap. This period-dependent separation is the signal the classification model exploits in semesters and loses in Summer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="docs/fig_weekday_weekend.png" class="img-fluid figure-img"></p>
<figcaption>Weekday vs weekend by period</figcaption>
</figure>
</div>
<hr>
</section>
<section id="weekday-vs.-weekend-classification" class="level3">
<h3 class="anchored" data-anchor-id="weekday-vs.-weekend-classification">Weekday vs.&nbsp;Weekend Classification</h3>
<p><strong>Metric:</strong> <strong>Gradient Boosting</strong> achieved <strong>84% accuracy</strong> and <strong>AUC 0.82</strong> on a held-out December test set (23 weekdays, 8 weekends), vs.&nbsp;a majority-class baseline of <strong>74%</strong>.</p>
<p><strong>Narrative:</strong> Using 27 features (24 hourly step counts plus total steps, peak hour, and active hours), the classifier learned discriminative structure: the most important hours were <strong>5 PM, 6 PM, 10 PM, and 9 AM</strong> — times when a school-day schedule diverges most from unstructured rest. December was chosen deliberately as a hard test set (winter break blurs weekday/weekend), so the model’s confusion on some weekends reflects reality rather than a flaw. The 10-point lift over baseline indicates the model captured genuine pattern, not class imbalance.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="docs/fig_classification.png" class="img-fluid figure-img"></p>
<figcaption>Classification results</figcaption>
</figure>
</div>
<hr>
</section>
<section id="next-day-step-forecasting" class="level3">
<h3 class="anchored" data-anchor-id="next-day-step-forecasting">Next-Day Step Forecasting</h3>
<p><strong>Metric:</strong> <strong>Linear Regression</strong> with lag and rolling features achieved <strong>R² ≈ 0.07</strong> on the December test set; Gradient Boosting performed worse (negative R²).</p>
<p><strong>Narrative:</strong> Predictions cluster near the mean (roughly 7,000–8,000 steps) while actual daily steps range from about 2,000 to 18,000. Daily <em>volume</em> depends on many unobserved factors (weather, plans, errands) and is not reliably predictable from step history alone. The takeaway: <strong>hourly pattern</strong> (when you move) is learnable; <strong>daily magnitude</strong> (how much you move) is not, from this feature set. The contrast with classification is itself an insight.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="docs/fig_forecasting.png" class="img-fluid figure-img"></p>
<figcaption>Forecasting results</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="recommendations" class="level2">
<h2 class="anchored" data-anchor-id="recommendations">Recommendations</h2>
<ol type="1">
<li><p><strong>Use period-aware goals.</strong> Set step targets by period (e.g., higher in Fall, lower in Summer) rather than a single annual target, to match observed structure and avoid discouragement in low-structure periods.</p></li>
<li><p><strong>Treat weekday vs.&nbsp;weekend as a design lever.</strong> Where the goal is to increase activity, focus on weekend and break periods where the data show the largest gap versus weekdays and the least discriminative structure.</p></li>
<li><p><strong>Rely on patterns, not point forecasts.</strong> Use hourly or daily <em>patterns</em> (e.g., “weekday-like” vs.&nbsp;“weekend-like”) for insights or nudges; avoid relying on next-day step predictions for individual daily targets.</p></li>
<li><p><strong>Extend with more signals.</strong> Incorporate heart rate, sleep, or workout data from the same export to improve classification and to explore whether volume becomes more predictable with additional context.</p></li>
</ol>
<hr>
</section>
<section id="caveats-assumptions" class="level2">
<h2 class="anchored" data-anchor-id="caveats-assumptions">Caveats &amp; Assumptions</h2>
<ul>
<li><p><strong>Single metric, single year, single user.</strong> Conclusions are specific to 2025 and to the individual’s schedules and campuses; generalizability to other years or populations is untested.</p></li>
<li><p><strong>December as holdout.</strong> The classifier and forecast are evaluated on December (including winter break). This is a conservative, “hard” test; a mid-semester holdout would likely show higher accuracy but would miss the break-period behavior.</p></li>
<li><p><strong>Apple Health as source of truth.</strong> Step counts are taken from the iPhone export as-is; no independent validation of device accuracy or completeness (e.g., phone not carried) is applied.</p></li>
</ul>
<hr>
</section>
<section id="technical-implementation" class="level2">
<h2 class="anchored" data-anchor-id="technical-implementation">Technical Implementation</h2>
<p>Analysis is implemented in a single Jupyter notebook. Technical details (XML stream parsing, feature engineering, train/test splits, and model choices) are documented in the notebook itself. For replication:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 35%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>Asset</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Notebook</strong></td>
<td><code>health_data_2025.ipynb</code> — load and filter data, daily aggregation, period definitions, visualizations, Mann-Whitney U tests, hourly feature construction, classification (Logistic Regression, Random Forest, Gradient Boosting), and next-day regression.</td>
</tr>
<tr class="even">
<td><strong>Dependencies</strong></td>
<td><code>requirements.txt</code> — Python 3.12, pandas, NumPy, matplotlib, scikit-learn, SciPy.</td>
</tr>
<tr class="odd">
<td><strong>Data</strong></td>
<td>Place Apple Health <code>export.xml</code> in a <code>data/</code> folder at project root; the notebook filters to 2025 and a single source device.</td>
</tr>
</tbody>
</table>
<p><strong>How to run:</strong> Clone the repository, install with <code>pip install -r requirements.txt</code>, add <code>data/export.xml</code>, and run all cells in <code>health_data_2025.ipynb</code>.</p>
<pre><code>2025-health-analysis/
├── health_data_2025.ipynb
├── requirements.txt
├── .gitignore
├── README.md
└── data/
    └── export.xml          # Not tracked; user-provided</code></pre>
<p>The raw <code>export.xml</code> file is not included in the repository due to size and privacy. The notebook is designed to work with any Apple Health export that follows the same XML schema.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>